# `fav_2` variables rounded to 1 decimal places
round_1 <- round(fav_1,1)
round_2 <- round(fav_2,1)
# Create a variable `sum_round` that is the sum of the rounded values
sum_round <- sum(round_1,round_2)
# Which is bigger, `round_sum` or `sum_round`? (You can use the `max()` function!)
print(max(round_sum,sum_round))
# Create a variable `lyric` that contains the text "I like to eat apples and
# bananas"
lyric <- "I like to eat apples and bananas"
# Use the `substr()` function to extract the 1st through 13th letters from the
# `lyric`, and store the result in a variable called `intro`
# Use `?substr` to see more about this function
intro <- substr(lyric(1:13))
# Use the `substr()` function to extract the 1st through 13th letters from the
# `lyric`, and store the result in a variable called `intro`
# Use `?substr` to see more about this function
intro <- substr(lyric[1:13])
?substr
# Use the `substr()` function to extract the 1st through 13th letters from the
# `lyric`, and store the result in a variable called `intro`
# Use `?substr` to see more about this function
intro <- substr(lyric,1,13)
# Use the `substr()` function to extract the 15th through the last letter of the
# `lyric`, and store the result in a variable called `fruits`
# Hint: use `nchar()` to determine how many total letters there are!
fruits <- substr(lyric,15,nchar(lyric))
?gsub
# Use the `gsub()` function to substitute all the "a"s in `fruits` with "ee".
# Store the result in a variable called `fruits_e`
# Hint: see http://www.endmemo.com/program/R/sub.php for a simpmle example (or
# use `?gsub`)
fruits_e <- gsub("a", "ee", fruits, ignore.case = FALSE, perl = FALSE,
fixed = FALSE, useBytes = FALSE)
# Use the `gsub()` function to substitute all the "a"s in `fruits` with "o".
# Store the result in a variable called `fruits_o`
fruits_o <- gsub("a", "o", fruits, ignore.case = FALSE, perl = FALSE,
fixed = FALSE, useBytes = FALSE)
# Create a new variable `lyric_e` that is the `intro` combined with the new
# `fruits_e` ending. Print out this variable
lyric_e <- paste(intro,fruits_e)
print(lyric_e)
# Without making a new variable, print out the `intro` combined with the new
# `fruits_o` ending
print(paste(intro,fruits_o))
return input+3
return(input+3)
# Define a function `add_three` that takes a single argument and
# returns a value 3 greater than the input
add_three <- function(input){
output = input+3
return(output)
}
# Create a variable `ten` that is the result of passing 7 to your `add_three`
# function
ten <- add_three(7)
return(inches*0.0254)
# Define a function `imperial_to_metric` that takes in two arguments: a number
# of feet and a number of inches
# The function should return the equivalent length in meters
imperial_to_metric <- function(feet,inches){
inches = feet*12+inches
return(inches*0.0254)
}
# Create a variable `height_in_meters` by passing your height in imperial to the
# `imperial_to_metric` function
height_in_meters <- imperial_to_metric(5,10)
# Define a function `is_twice_as_long` that takes in two character strings, and
# returns whether or not (e.g., a boolean) the length of one argument is greater
# than or equal to twice the length of the other.
# Hint: compare the length difference to the length of the smaller string
is_twice_as_long <- function(string1,string2){
length_diff <- abs(nchar(string1)-nchar(string2))
sstring <- min(nchar(string1,string2))
return(length_diff >= sstring)
}
# Call your `is_twice_as_long` function by passing it different length strings
# to confirm that it works. Make sure to check when _either_ argument is twice
# as long, as well as when neither are!
rtrue <- is_twice_long("funner","fun")
# Call your `is_twice_as_long` function by passing it different length strings
# to confirm that it works. Make sure to check when _either_ argument is twice
# as long, as well as when neither are!
rtrue <- is_twice_as_long("funner","fun")
# Define a function `is_twice_as_long` that takes in two character strings, and
# returns whether or not (e.g., a boolean) the length of one argument is greater
# than or equal to twice the length of the other.
# Hint: compare the length difference to the length of the smaller string
is_twice_as_long <- function(string1,string2){
length_diff <- abs(nchar(string1)-nchar(string2))
sstring <- min(nchar(string1),nchar(string2))
return(length_diff >= sstring)
}
# Call your `is_twice_as_long` function by passing it different length strings
# to confirm that it works. Make sure to check when _either_ argument is twice
# as long, as well as when neither are!
rtrue <- is_twice_as_long("funner","fun")
rfalse <- is_twice_as_long("fun","fund")
# Define a function `describe_difference` that takes in two strings. The
# function should return one of the following sentences as appropriate
#   "Your first string is longer by N characters"
#   "Your second string is longer by N characters"
#   "Your strings are the same length!"
describe_difference <- function(string1,string2){
ns1 <- nchar(string1)
ns2 <- nchar(string2)
if(ns1 > ns2){
return("Your first string is longer by N characters")
} else if(ns2 > ns1){
return("Your second string is longer by N characters")
} else {
return("Your strings are the same length!")
}
}
# Call your `describe_difference` function by passing it different length strings
# to confirm that it works. Make sure to check all 3 conditions1
equal <- describe_difference("fun","run")
string1_bigger <- describe_difference("then","the")
string2_bigger <- describe_difference("the","then")
return(paste("Your first string is longer by ",difference, "characters")
} else if(ns2 > ns1){
return("Your second string is longer by N characters")
} else {
return("Your strings are the same length!")
}
}
# Call your `describe_difference` function by passing it different length strings
# to confirm that it works. Make sure to check all 3 conditions1
equal <- describe_difference("fun","run")
string1_bigger <- describe_difference("then","the")
string2_bigger <- describe_difference("the","then")
return(paste("Your first string is longer by ",difference, "characters"))
ns2 <- nchar(string2)
# Define a function `describe_difference` that takes in two strings. The
# function should return one of the following sentences as appropriate
#   "Your first string is longer by N characters"
#   "Your second string is longer by N characters"
#   "Your strings are the same length!"
describe_difference <- function(string1,string2){
ns1 <- nchar(string1)
ns2 <- nchar(string2)
difference <- abs(ns1 - ns2)
if(ns1 > ns2){
return(paste("Your first string is longer by ",difference, "characters"))
} else if(ns2 > ns1){
return("Your second string is longer by N characters")
} else {
return("Your strings are the same length!")
}
}
# Call your `describe_difference` function by passing it different length strings
# to confirm that it works. Make sure to check all 3 conditions1
equal <- describe_difference("fun","run")
string1_bigger <- describe_difference("then","the")
# Define a function `describe_difference` that takes in two strings. The
# function should return one of the following sentences as appropriate
#   "Your first string is longer by N characters"
#   "Your second string is longer by N characters"
#   "Your strings are the same length!"
string1_bigger <- describe_difference("then","the")
string2_bigger <- describe_difference("the","then")
# Define a function `describe_difference` that takes in two strings. The
# function should return one of the following sentences as appropriate
#   "Your first string is longer by N characters"
#   "Your second string is longer by N characters"
#   "Your strings are the same length!"
describe_difference <- function(string1,string2){
ns1 <- nchar(string1)
ns2 <- nchar(string2)
difference <- abs(ns1 - ns2)
if(ns1 > ns2){
return(paste("Your first string is longer by ",difference, "characters"))
} else if(ns2 > ns1){
return(paste("Your second string is longer by ",difference, "characters"))
} else {
return("Your strings are the same length!")
}
}
# Call your `describe_difference` function by passing it different length strings
# to confirm that it works. Make sure to check all 3 conditions1
equal <- describe_difference("fun","run")
string1_bigger <- describe_difference("then","the")
string2_bigger <- describe_difference("the","then")
# Create a vector `names` that contains your name and the names of 2 people
# next to you. Print the vector.
names <-c("Mathew","Hilton","Allen")
# Use the colon operator : to create a vector `n` of numbers from 10:49
n <- 10:49
# Use the `length()` function to get the number of elements in `n`
length(n)
# Add 1 to each element in `n` and print the result
n = n + 1
print(n)
?seq
# Create a vector `m` that contains the numbers 10 to 1 (in that order).
# Hint: use the `seq()` function
m <- seq(10,1,-1)
# Subtract `m` FROM `n`. Note the recycling!
m-n
# Use the `seq()` function to produce a range of numbers from -5 to 10 in `0.1`
# increments. Store it in a variable `x_range`
x_range <- seq(-5,10,0.1)
# Create a vector `sin_wave` by calling the `sin()` function on each element
# in `x_range`.
sin_wave <- sin(x_range)
# Create a vector `cos_wave` by calling the `cos()` function on each element
# in `x_range`.
cos_wave <- cos(x_range)
# Create a vector `wave` by multiplying `sin_wave` and `cos_wave` together, then
# adding `sin_wave` to the product
wave <- sin_wave * cos_wave + sin_wave
# Use the `plot()` function to plot your `wave`!
plot(x_range,wave)
# Create a vector `first_ten` that has the values 10 through 20 in it (using
# the : operator)
first_ten <- 10:20
# Create a vector `next_ten` that has the values 21 through 30 in it (using the
# seq() function)
next_ten <- seq(21,30)
# Create a vector `all_numbers` by combining the previous two vectors
all_numbers <- c(first_ten,next_ten)
print(all_numbers)
# Create a variable `eleventh` that contains the 11th element in `all_numbers`
eleventh <- all_numbers[11]
# Create a vector `some_numbers` that contains the 2nd through the 5th elements
# of `all_numbers`
some_numbers <- allnumbers[2:5]
# Create a vector `some_numbers` that contains the 2nd through the 5th elements
# of `all_numbers`
some_numbers <- all_numbers[2:5]
# Create a vector `even` that holds the even numbers from 1 to 100
even <- seq(2,100,2)
?all
# Using the `all()` function and `%%` (modulo) operator, confirm that all of the
# numbers in your `even` vector are even
all(even %% 1)
# Using the `all()` function and `%%` (modulo) operator, confirm that all of the
# numbers in your `even` vector are even
all(even %% 2)
# Using the `all()` function and `%%` (modulo) operator, confirm that all of the
# numbers in your `even` vector are even
logical <- even %% 2
all(logical)
# Using the `all()` function and `%%` (modulo) operator, confirm that all of the
# numbers in your `even` vector are even
logical <- even %% 1
all(logical)
# Using the `all()` function and `%%` (modulo) operator, confirm that all of the
# numbers in your `even` vector are even
logical <- even %% 1
# Using the `all()` function and `%%` (modulo) operator, confirm that all of the
# numbers in your `even` vector are even
logical <- even %% 2 == 0
# Using the `all()` function and `%%` (modulo) operator, confirm that all of the
# numbers in your `even` vector are even
all(even %% 2 == 0)
# Create a vector `phone_numbers` that contains the numbers 8, 6, 7, 5, 3, 0, 9
phone_numbers <- c(8,6,7,5,3,0,9)
# Create a vector `prefix` that has the first three elements of `phone_numbers`
prefix <- phone_numbers[1:3]
# Create a vector `small` that has the values of `phone_numbers` that are
# less than or equal to 5
small <- phone_numbers[phone_numbers < 5]
# Create a vector `large` that has the values of `phone_numbers` that are
# strictly greater than 5
large <- phone_numbers[phone_numbers > 5]
# Replace the values in `phone_numbers` that are larger than 5 with the number 5
phone_numbers[phone_numbers > 5] <- 5
# Replace every odd-numbered value in `phone_numbers` with the number 0
phone_numbers[seq(1:length(phone_numbers))] <- 0
# Replace every odd-numbered value in `phone_numbers` with the number 0
phone_numbers[seq(1,length(phone_numbers)),2] <- 0
# Replace the values in `phone_numbers` that are larger than 5 with the number 5
phone_numbers[phone_numbers > 5] <- 5
# Replace every odd-numbered value in `phone_numbers` with the number 0
phone_numbers[seq(1,length(phone_numbers)),2] <- 0
# Replace every odd-numbered value in `phone_numbers` with the number 0
phone_numbers[seq(1,length(phone_numbers),2)] <- 0
# Create a vector `phone_numbers` that contains the numbers 8, 6, 7, 5, 3, 0, 9
phone_numbers <- c(8,6,7,5,3,0,9)
# Create a vector `prefix` that has the first three elements of `phone_numbers`
prefix <- phone_numbers[1:3]
# Create a vector `small` that has the values of `phone_numbers` that are
# less than or equal to 5
small <- phone_numbers[phone_numbers < 5]
# Create a vector `large` that has the values of `phone_numbers` that are
# strictly greater than 5
large <- phone_numbers[phone_numbers > 5]
# Replace the values in `phone_numbers` that are larger than 5 with the number 5
phone_numbers[phone_numbers > 5] <- 5
# Replace every odd-numbered value in `phone_numbers` with the number 0
phone_numbers[seq(1,length(phone_numbers),2)] <- 0
install.packages(styler)
install.packages("styler")
install.packages("lintr")
install.packages("lintr")
install.packages(ggplot2)
install.packages("ggplot2")
# Install and load the `ggplot2` package
# You will also want to load `dplyr`
library(dplyr)
library(ggplot2)
?sample_n
# This data set has A LOT of rows. To make things a bit more readable,
# use dplyr's `sample_n()` function to get a random 1000 rows from the data set
# Store this sample in a variable `diamonds_sample`
sample <- sample_n(diamonds, 1000)
View(sample)
# Start by making a new `ggplot` with the `diamonds_sample` as the data (no
# geometry yet)
# What do you see? (What did you expect?)
ggplot(data = sample)
# Draw a scatter plot (with point geometry) with for the `diamonds_sample` set,
# with the `carat` mapped to the x-position and `price` mapped to the y-position.
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = price))
# Draw the same plot as above, but color each of the points based on their
# clarity.
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw the same plot as above, but for the entire `diamonds` data set. Note this
# may take a few seconds to generate.
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw another scatter plot for `diamonds_sample` of price (y) by carat (x),
# but with all of the dots colored "blue".
# Hint: you'll need to set the color channel, not map a value to it!
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price), color = "blue")
# Draw another scatter plot for `diamonds_sample` of price (y) by carat (x),
# but with all of the dots colored "blue".
# Hint: you'll need to set the color channel, not map a value to it!
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = price), color = "blue")
# Draw a scatter plot for `diamonds_sample` of `price` by `carat`, where each
# point has an aesthetic _shape_ based on the diamond's `cut`.
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = price, shape = cut))
# Draw a scatter plot for `diamonds_sample` of *`cut`* by `carat`, where each
# point has an aesthetic _size_ based on the diamond's *`price`*
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = cut, size = price))
# Try coloring the above plot based on the diamond's price!
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = cut, size = price, color = price))
ggplot(data = sample) +
geom_line(mapping = aes(x = carat, y = price, color = cut))
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Draw a plot with bar geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis
ggplot(data = sample) +
geom_bar(mapping = aes(x = cut))
# Add an aesthetic property that will _fill_ each bar geometry based on the
# `clarity` of the diamonds.
# What kind of chart do you get?
ggplot(data = sample) +
geom_bar(mapping = aes(x = cut, fill = clarity))
# Draw a histogram (using histogram geometry) of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = sample) +
geom_histogram(mapping = aes(x = price, x = clarity))
# Draw a histogram (using histogram geometry) of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = sample) +
geom_histogram(mapping = aes(x = price, fill = clarity))
# (For a more traditional "bell-curve", make a histogram of diamond `depth`)
ggplot(data = sample) +
geom_histogram(mapping = aes(x = depth))
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = carat, aplha = 0.3)) +
geom_smooth(mapping = aes(x = carat, y = carat, alpha = 0.3))
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = carat), alpha = 0.3) +
geom_smooth(mapping = aes(x = carat, y = carat), alpha = 0.3)
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = carat), alpha = 0.3) +
geom_smooth(mapping = aes(x = carat, y = carat), alpha = 0.3, SE = FALSE)
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = carat, color = cut), alpha = 0.3) +
geom_smooth(mapping = aes(x = carat, y = carat, color = cut), se = FALSE)
install.packages("RColorBrewer")
# Install and load the `ggplot2` package
#install.packages('ggplot2')
library(ggplot2)
# Draw a bar chart of the diamonds data, organized by cut
# Each bar's height is based on the "count" (number) of diamonds with that cut
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut))
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
stat_count(mapping = aes(x = cut))
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median`
# as the function y
ggplot(data = diamonds) +
stat_summary(mapping = aes(x = cut, y = depth),fun.ymin = min(),fun.ymax = max())
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median`
# as the function y
ggplot(data = diamonds) +
stat_summary(mapping = aes(x = cut, y = depth))
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median`
# as the function y
ggplot(data = diamonds) +
stat_summary(mapping = aes(x = cut, y = depth),,
fun.ymin = min(),fun.ymax = max(), fun.data = median())
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median`
# as the function y
ggplot(data = diamonds) +
stat_summary(mapping = aes(x = cut, y = depth),
fun.ymin = min(),fun.ymax = max(), fun.data = median())
# Draw a bar chart of diamonds organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, filled = clarity))
# Draw a bar chart of diamonds organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut), fill = clarity)
# Draw a bar chart of diamonds organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut), filled = clarity)
# Draw a bar chart of diamonds organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity))
# Draw the same chart again, but with each element positioned to "fill" the y axis
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
# Draw the same chart again, but with each element positioned to "dodge" each other
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
# Draw a plot with point geometry with the x-position mapped to `cut` and the
# y-position mapped to `clarity`
# This creates a "grid" grouping the points
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity))
# Use the "jitter" position adjustment to keep the points from all overlapping!
# (This works a little better with a sample of diamond data, such as from the
# previous exercise).
sample <- sample_n(diamonds, 1000)
ggplot(data = sample) +
geom_point(mapping = aes(x = cut, y = clarity), position = "jitter")
# Draw a "boxplot" (with `geom_boxplot`) for the diamond's price (y) by color (x)
ggplot(data = diamonds) +
geom_boxplot(mapping = aes(x = color, y = price))
# This has a lot of outliers, making it harder to read. To fix this, draw the
# same plot but with a _logarithmic_ scale for the y axis.
ggplot(data = diamonds) +
geom_boxplot(mapping = aes(x = color, y = price))+
scale_x_log10()
# This has a lot of outliers, making it harder to read. To fix this, draw the
# same plot but with a _logarithmic_ scale for the y axis.
ggplot(data = diamonds) +
geom_boxplot(mapping = aes(x = color, y = price))+
scale_y_log10()
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median`
# as the function y
ggplot(data = diamonds) +
stat_summary(mapping = aes(x = cut, y = depth)) +
labs(x = "Cut", y = "Price")
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
ggplot(data = sample) +
geom_bar(mapping = aes(x = cut, fill = clarity))
sample <- sample_n(diamonds, 1000)
ggplot(data = sample) +
geom_point(mapping = aes(x = cut, y = clarity), position = "jitter")
ggplot(data = diamonds) +
geom_boxplot(mapping = aes(x = color, y = price)) +
scale_y_log10()
ggplot(data = sample) +
geom_point(mapping = aes(x = carat, y = carat, color = cut), alpha = 0.3) +
geom_smooth(mapping = aes(x = carat, y = carat, color = cut), se = FALSE)
ggplot(data = sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
install.packages(shiny)
install.packages("shiny")
# Load the `shiny` package (install it in the R terminal if you haven't already)
library(shiny)
# Load the `shiny` package (install it in the R terminal if you haven't already)
library(shiny)
source('~/School/INFO201/Project/Info-201-BA3/MakeAverageTempPerYear.R', echo=TRUE)
setwd("~/School/INFO201/Project/Info-201-BA3")
source('~/School/INFO201/Project/Info-201-BA3/MakeAverageTempPerYear.R', echo=TRUE)
source('~/School/INFO201/Project/Info-201-BA3/MakeAverageTempPerYear.R', echo=TRUE)
source('~/School/INFO201/Project/Info-201-BA3/MakeAverageTempPerYear.R', echo=TRUE)
source('~/School/INFO201/Project/Info-201-BA3/MakeAverageTempPerYear.R', echo=TRUE)
